Description: symlink traversal fix for CVE-2017-1000115
 This is a backport of two upstream patches from "stable" released as
 part of 4.3.1. Some interpretation was necessary for the patch to
 apply at all, but it is believed all use cases are covered, as the
 upstream-provided tests pass. One tests for the `files` command was
 removed as the command doesn't exist in 2.2.2. 
Author: Antoine Beaupr√© <anarcat@debian.org>
Bug-Debian: https://bugs.debian.org/871709
Origin: upstream, https://www.mercurial-scm.org/repo/hg/rev/47ea28293d30 and https://www.mercurial-scm.org/repo/hg/rev/377e8ddaebef
Forwarded: not-needed
Last-Update: 2017-08-28

--- a/tests/test-audit-path.t
+++ b/tests/test-audit-path.t
@@ -82,3 +82,98 @@ attack /tmp/test
   $ hg update -Cr4
   abort: *: $TESTTMP/target//tmp/test (glob)
   [255]
+
+Test symlink traversal on merge:
+--------------------------------
+
+#if symlink
+
+set up symlink hell
+
+  $ mkdir merge-symlink-out
+  $ hg init merge-symlink
+  $ cd merge-symlink
+  $ touch base
+  $ hg commit -qAm base
+  $ ln -s ../merge-symlink-out a
+  $ hg commit -qAm 'symlink a -> ../merge-symlink-out'
+  $ hg up -q 0
+  $ mkdir a
+  $ touch a/poisoned
+  $ hg commit -qAm 'file a/poisoned'
+  $ hg log --template '{rev}: {desc}\n'
+  2: file a/poisoned
+  1: symlink a -> ../merge-symlink-out
+  0: base
+
+
+try trivial merge
+
+  $ hg up -qC 1
+  $ hg merge 2
+  abort: path 'a/poisoned' traverses symbolic link 'a'
+  [255]
+
+try rebase onto other revision: cache of audited paths should be discarded,
+and the rebase should fail (issue5628)
+
+  $ hg up -qC 2
+  $ hg rebase -s 2 -d 1 --config extensions.rebase=
+  abort: path 'a/poisoned' traverses symbolic link 'a'
+  [255]
+  $ ls ../merge-symlink-out
+
+  $ cd ..
+
+Test symlink traversal on update:
+---------------------------------
+
+  $ mkdir update-symlink-out
+  $ hg init update-symlink
+  $ cd update-symlink
+  $ ln -s ../update-symlink-out a
+  $ hg commit -qAm 'symlink a -> ../update-symlink-out'
+  $ hg rm a
+  $ mkdir a && touch a/b
+  $ hg ci -qAm 'file a/b' a/b
+  $ hg up -qC 0
+  $ hg rm a
+  $ mkdir a && touch a/c
+  $ hg ci -qAm 'rm a, file a/c'
+  $ hg log --template '{rev}: {desc}\n'
+  2: rm a, file a/c
+  1: file a/b
+  0: symlink a -> ../update-symlink-out
+
+
+try linear update where symlink already exists:
+
+  $ hg up -qC 0
+  $ hg up 1
+  abort: path 'a/b' traverses symbolic link 'a'
+  [255]
+
+try linear update including symlinked directory and its content: paths are
+audited first by calculateupdates(), where no symlink is created so both
+'a' and 'a/b' are taken as good paths. still applyupdates() should fail.
+
+  $ hg up -qC null
+  $ hg up 1
+  abort: path 'a/b' traverses symbolic link 'a'
+  [255]
+  $ ls ../update-symlink-out
+
+try branch update replacing directory with symlink, and its content: the
+path 'a' is audited as a directory first, which should be audited again as
+a symlink.
+
+  $ rm -f a
+  $ hg up -qC 2
+  $ hg up 1
+  abort: path 'a/b' traverses symbolic link 'a'
+  [255]
+  $ ls ../update-symlink-out
+
+  $ cd ..
+
+#endif
--- a/tests/test-commandserver.py
+++ b/tests/test-commandserver.py
@@ -233,6 +233,30 @@ def hgignore(server):
     f.close()
     runcommand(server, ['status', '-i', '-u'])
 
+
+def symlink_hell():
+    os.system("mkdir merge-symlink-out")
+    os.system("hg init merge-symlink")
+    os.chdir("merge-symlink")
+    os.system("touch base")
+    os.system("hg commit -qAm base")
+    os.system("ln -s ../merge-symlink-out a")
+    os.system("hg commit -qAm 'symlink a -> ../merge-symlink-out'")
+    os.system("hg up -q 0")
+    os.system("mkdir a")
+    os.system("touch a/poisoned")
+    os.system("hg commit -qAm 'file a/poisoned'")
+
+
+def merge(server):
+    readchannel(server)
+    # audit a/poisoned as a good path
+    runcommand(server,  ['up', '-qC', '2'])
+    runcommand(server, ['up', '-qC', '1'])
+    # here a is a symlink, so a/poisoned is bad
+    runcommand(server, ['merge', '2'])
+
+
 if __name__ == '__main__':
     os.system('hg init')
 
@@ -255,3 +279,9 @@ if __name__ == '__main__':
     check(rollback)
     check(branch)
     check(hgignore)
+
+    symlink_hell()
+    os.system("hg up -q null")
+    check(merge)
+    if os.path.exists("../merge-symlink-out/poisoned"):
+        raise AssertionError('../merge-symlink-out/poisoned should not exist: server vulnerable to symlink traversal')
--- a/tests/test-commandserver.py.out
+++ b/tests/test-commandserver.py.out
@@ -163,3 +163,10 @@ testing hgignore:
 adding .hgignore
  runcommand status -i -u
 I ignored-file
+
+testing merge:
+
+ runcommand up -qC 2
+ runcommand up -qC 1
+ runcommand merge 2
+abort: path 'a/poisoned' traverses symbolic link 'a'
--- a/mercurial/cmdutil.py
+++ b/mercurial/cmdutil.py
@@ -1596,7 +1596,7 @@ def revert(ui, repo, ctx, parents, *pats
                 fc = ctx[f]
                 repo.wwrite(f, fc.data(), fc.flags())
 
-            audit_path = scmutil.pathauditor(repo.root)
+            audit_path = scmutil.pathauditor(repo.root, cached=True)
             for f in remove[0]:
                 if repo.dirstate[f] == 'a':
                     repo.dirstate.drop(f)
--- a/mercurial/localrepo.py
+++ b/mercurial/localrepo.py
@@ -36,8 +36,9 @@ class localrepository(repo.repository):
         self.root = os.path.realpath(util.expandpath(path))
         self.path = os.path.join(self.root, ".hg")
         self.origroot = path
-        self.auditor = scmutil.pathauditor(self.root, self._checknested)
-        self.opener = scmutil.opener(self.path)
+        self.auditor = scmutil.pathauditor(self.root, self._checknested,
+                                           cached=True)
+        self.opener = scmutil.opener(self.path, cacheaudited=True)
         self.wopener = scmutil.opener(self.root)
         self.baseui = baseui
         self.ui = baseui.copy()
@@ -98,7 +99,8 @@ class localrepository(repo.repository):
             if inst.errno != errno.ENOENT:
                 raise
 
-        self.store = store.store(requirements, self.sharedpath, scmutil.opener)
+        self.store = store.store(requirements, self.sharedpath,
+                                 lambda base: scmutil.opener(base, cacheaudited=True))
         self.spath = self.store.path
         self.sopener = self.store.opener
         self.sjoin = self.store.join
--- a/mercurial/scmutil.py
+++ b/mercurial/scmutil.py
@@ -80,12 +80,17 @@ class pathauditor(object):
     - traverses a symlink (e.g. a/symlink_here/b)
     - inside a nested repository (a callback can be used to approve
       some nested repositories, e.g., subrepositories)
+
+    If 'cached' is set to True, audited paths and sub-directories are cached.
+    Be careful to not keep the cache of unmanaged directories for long because
+    audited paths may be replaced with symlinks.
     '''
 
-    def __init__(self, root, callback=None):
+    def __init__(self, root, callback=None, cached=False):
         self.audited = set()
         self.auditeddir = set()
         self.root = root
+        self._cached = cached
         self.callback = callback
         if os.path.lexists(root) and not util.checkcase(root):
             self.normcase = util.normcase
@@ -157,10 +162,11 @@ class pathauditor(object):
             parts.pop()
             normparts.pop()
 
-        self.audited.add(normpath)
-        # only add prefixes to the cache after checking everything: we don't
-        # want to add "foo/bar/baz" before checking if there's a "foo/.hg"
-        self.auditeddir.update(prefixes)
+        if self._cached:
+            self.audited.add(normpath)
+            # only add prefixes to the cache after checking everything: we don't
+            # want to add "foo/bar/baz" before checking if there's a "foo/.hg"
+            self.auditeddir.update(prefixes)
 
 class abstractopener(object):
     """Abstract base class; cannot be instantiated"""
@@ -204,12 +210,16 @@ class opener(abstractopener):
 
     This class is used to hide the details of COW semantics and
     remote file access from higher level code.
+
+    'cacheaudited' should be enabled only if (a) vfs object is short-lived, or
+    (b) the base directory is managed by hg and considered sort-of append-only.
+    See pathutil.pathauditor() for details.
     '''
-    def __init__(self, base, audit=True):
+    def __init__(self, base, audit=True, cacheaudited=False):
         self.base = base
         self._audit = audit
         if audit:
-            self.auditor = pathauditor(base)
+            self.auditor = pathauditor(base, cached=cacheaudited)
         else:
             self.auditor = util.always
         self.createmode = None
@@ -648,7 +658,7 @@ def addremove(repo, pats=[], opts={}, dr
         similarity = float(opts.get('similarity') or 0)
     # we'd use status here, except handling of symlinks and ignore is tricky
     added, unknown, deleted, removed = [], [], [], []
-    audit_path = pathauditor(repo.root)
+    audit_path = pathauditor(repo.root, cached=True)
     m = match(repo[None], pats, opts)
     rejected = []
     m.bad = lambda x, y: rejected.append(x)
--- a/mercurial/merge.py
+++ b/mercurial/merge.py
@@ -333,7 +333,7 @@ def applyupdates(repo, action, wctx, mct
             if f != fd and move:
                 moves.append(f)
 
-    audit = scmutil.pathauditor(repo.root)
+    audit = scmutil.pathauditor(repo.root, cached=True)
 
     # remove renamed files after safely stored
     for f in moves:
