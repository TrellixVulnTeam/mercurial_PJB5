OPTIONS
-------

-R, --repository::
    repository root directory or symbolic path name

--cwd::
    change working directory

-y, --noninteractive::
    do not prompt, assume 'yes' for any required answers

-q, --quiet::
    suppress output

-v, --verbose::
    enable additional output

--config::
    set/override config option

--debug::
    enable debugging output

--debugger::
    start debugger

--encoding::
    set the charset encoding (default: UTF-8)

--encodingmode::
    set the charset encoding mode (default: strict)

--lsprof::
    print improved command execution profile

--traceback::
    print traceback on exception

--time::
    time how long the command takes

--profile::
    print command execution profile

--version::
    output version information and exit

-h, --help::
    display help and exit

COMMANDS
--------

add [OPTION]... [FILE]...::
    Schedule files to be version controlled and added to the repository.

    The files will be added to the repository at the next commit. To
    undo an add before that, see hg revert.

    If no names are given, add all files in the repository.

    options:
    -I, --include  include names matching the given patterns
    -X, --exclude  exclude names matching the given patterns
    -n, --dry-run  do not perform actions, just print output

addremove [OPTION]... [FILE]...::
    Add all new files and remove all missing files from the repository.

    New files are ignored if they match any of the patterns in .hgignore. As
    with add, these changes take effect at the next commit.

    Use the -s option to detect renamed files.  With a parameter > 0,
    this compares every removed file with every added file and records
    those similar enough as renames.  This option takes a percentage
    between 0 (disabled) and 100 (files must be identical) as its
    parameter.  Detecting renamed files this way can be expensive.

    options:
    -s, --similarity  guess renamed files by similarity (0<=s<=100)
    -I, --include     include names matching the given patterns
    -X, --exclude     exclude names matching the given patterns
    -n, --dry-run     do not perform actions, just print output

annotate [-r REV] [-f] [-a] [-u] [-d] [-n] [-c] [-l] FILE...::
    List changes in files, showing the revision id responsible for each line

    This command is useful to discover who did a change or when a change took
    place.

    Without the -a option, annotate will avoid processing files it
    detects as binary. With -a, annotate will generate an annotation
    anyway, probably with undesirable results.

    options:
    -r, --rev          annotate the specified revision
    -f, --follow       follow file copies and renames
    -a, --text         treat all files as text
    -u, --user         list the author
    -d, --date         list the date
    -n, --number       list the revision number (default)
    -c, --changeset    list the changeset
    -l, --line-number  show line number at the first appearance
    -I, --include      include names matching the given patterns
    -X, --exclude      exclude names matching the given patterns

archive [OPTION]... DEST::
    By default, the revision used is the parent of the working
    directory; use "-r" to specify a different revision.

    To specify the type of archive to create, use "-t".  Valid
    types are:

    "files" (default): a directory full of files
    "tar": tar archive, uncompressed
    "tbz2": tar archive, compressed using bzip2
    "tgz": tar archive, compressed using gzip
    "uzip": zip archive, uncompressed
    "zip": zip archive, compressed using deflate

    The exact name of the destination archive or directory is given
    using a format string; see "hg help export" for details.

    Each member added to an archive file has a directory prefix
    prepended.  Use "-p" to specify a format string for the prefix.
    The default is the basename of the archive, with suffixes removed.

    options:
    --no-decode    do not pass files through decoders
    -p, --prefix   directory prefix for files in archive
    -r, --rev      revision to distribute
    -t, --type     type of distribution to create
    -I, --include  include names matching the given patterns
    -X, --exclude  exclude names matching the given patterns

backout [OPTION]... [-r] REV::
    Commit the backed out changes as a new changeset.  The new
    changeset is a child of the backed out changeset.

    If you back out a changeset other than the tip, a new head is
    created.  This head is the parent of the working directory.  If
    you back out an old changeset, your working directory will appear
    old after the backout.  You should merge the backout changeset
    with another head.

    The --merge option remembers the parent of the working directory
    before starting the backout, then merges the new head with that
    changeset afterwards.  This saves you from doing the merge by
    hand.  The result of this merge is not committed, as for a normal
    merge.

    options:
    --merge        merge with old dirstate parent after backout
    --parent       parent to choose when backing out merge
    -r, --rev      revision to backout
    -I, --include  include names matching the given patterns
    -X, --exclude  exclude names matching the given patterns
    -m, --message  use <text> as commit message
    -l, --logfile  read commit message from <file>
    -d, --date     record datecode as commit date
    -u, --user     record user as committer

branch [NAME]::
    With no argument, show the current branch name. With one argument,
    set the working directory branch name (the branch does not exist in
    the repository until the next commit).

    Unless --force is specified, branch will not let you set a
    branch name that shadows an existing branch.

    options:
    -f, --force  set branch name even if it shadows an existing branch

branches [-a]::
    List the repository's named branches, indicating which ones are
    inactive.  If active is specified, only show active branches.

    A branch is considered active if it contains unmerged heads.

    options:
    -a, --active  show only branches that have unmerged heads

bundle [-f] [-r REV]... [--base REV]... FILE [DEST]::
    Generate a compressed changegroup file collecting changesets not
    found in the other repository.

    If no destination repository is specified the destination is assumed
    to have all the nodes specified by one or more --base parameters.

    The bundle file can then be transferred using conventional means and
    applied to another repository with the unbundle or pull command.
    This is useful when direct push and pull are not available or when
    exporting an entire repository is undesirable.

    Applying bundles preserves all changeset contents including
    permissions, copy/rename information, and revision history.

    options:
    -f, --force  run even when remote repository is unrelated
    -r, --rev    a changeset you would like to bundle
    --base       a base changeset to specify instead of a destination
    -e, --ssh    specify ssh command to use
    --remotecmd  specify hg command to run on the remote side

cat [OPTION]... FILE...::
    Print the specified files as they were at the given revision.
    If no revision is given, the parent of the working directory is used,
    or tip if no revision is checked out.

    Output may be to a file, in which case the name of the file is
    given using a format string.  The formatting rules are the same as
    for the export command, with the following additions:

    %s   basename of file being printed
    %d   dirname of file being printed, or '.' if in repo root
    %p   root-relative path name of file being printed

    options:
    -o, --output   print output to file with formatted name
    -r, --rev      print the given revision
    -I, --include  include names matching the given patterns
    -X, --exclude  exclude names matching the given patterns

clone [OPTION]... SOURCE [DEST]::
    Create a copy of an existing repository in a new directory.

    If no destination directory name is specified, it defaults to the
    basename of the source.

    The location of the source is added to the new repository's
    .hg/hgrc file, as the default to be used for future pulls.

    For efficiency, hardlinks are used for cloning whenever the source
    and destination are on the same filesystem (note this applies only
    to the repository data, not to the checked out files).  Some
    filesystems, such as AFS, implement hardlinking incorrectly, but
    do not report errors.  In these cases, use the --pull option to
    avoid hardlinking.

    You can safely clone repositories and checked out files using full
    hardlinks with

      $ cp -al REPO REPOCLONE

    which is the fastest way to clone. However, the operation is not
    atomic (making sure REPO is not modified during the operation is
    up to you) and you have to make sure your editor breaks hardlinks
    (Emacs and most Linux Kernel tools do so).

    If you use the -r option to clone up to a specific revision, no
    subsequent revisions will be present in the cloned repository.
    This option implies --pull, even on local repositories.

    See pull for valid source format details.

    It is possible to specify an ssh:// URL as the destination, but no
    .hg/hgrc and working directory will be created on the remote side.
    Look at the help text for the pull command for important details
    about ssh:// URLs.

    options:
    -U, --noupdate  do not update the new working directory
    -r, --rev       a changeset you would like to have after cloning
    --pull          use pull protocol to copy metadata
    --uncompressed  use uncompressed transfer (fast over LAN)
    -e, --ssh       specify ssh command to use
    --remotecmd     specify hg command to run on the remote side

commit [OPTION]... [FILE]...::
    Commit changes to the given files into the repository.

    If a list of files is omitted, all changes reported by "hg status"
    will be committed.

    If no commit message is specified, the editor configured in your hgrc
    or in the EDITOR environment variable is started to enter a message.

    options:
    -A, --addremove  mark new/missing files as added/removed before
                     committing
    -I, --include    include names matching the given patterns
    -X, --exclude    exclude names matching the given patterns
    -m, --message    use <text> as commit message
    -l, --logfile    read commit message from <file>
    -d, --date       record datecode as commit date
    -u, --user       record user as committer

    aliases: ci

copy [OPTION]... [SOURCE]... DEST::
    Mark dest as having copies of source files.  If dest is a
    directory, copies are put in that directory.  If dest is a file,
    there can only be one source.

    By default, this command copies the contents of files as they
    stand in the working directory.  If invoked with --after, the
    operation is recorded, but no copying is performed.

    This command takes effect in the next commit. To undo a copy
    before that, see hg revert.

    options:
    -A, --after    record a copy that has already occurred
    -f, --force    forcibly copy over an existing managed file
    -I, --include  include names matching the given patterns
    -X, --exclude  exclude names matching the given patterns
    -n, --dry-run  do not perform actions, just print output

    aliases: cp

diff [OPTION]... [-r REV1 [-r REV2]] [FILE]...::
    Show differences between revisions for the specified files.

    Differences between files are shown using the unified diff format.

    NOTE: diff may generate unexpected results for merges, as it will
    default to comparing against the working directory's first parent
    changeset if no revisions are specified.

    When two revision arguments are given, then changes are shown
    between those revisions. If only one revision is specified then
    that revision is compared to the working directory, and, when no
    revisions are specified, the working directory files are compared
    to its parent.

    Without the -a option, diff will avoid generating diffs of files
    it detects as binary. With -a, diff will generate a diff anyway,
    probably with undesirable results.

    options:
    -r, --rev                  revision
    -a, --text                 treat all files as text
    -p, --show-function        show which function each change is in
    -g, --git                  use git extended diff format
    --nodates                  don't include dates in diff headers
    -w, --ignore-all-space     ignore white space when comparing lines
    -b, --ignore-space-change  ignore changes in the amount of white
                               space
    -B, --ignore-blank-lines   ignore changes whose lines are all
                               blank
    -I, --include              include names matching the given
                               patterns
    -X, --exclude              exclude names matching the given
                               patterns

export [OPTION]... [-o OUTFILESPEC] REV...::
    Print the changeset header and diffs for one or more revisions.

    The information shown in the changeset header is: author,
    changeset hash, parent(s) and commit comment.

    NOTE: export may generate unexpected diff output for merge changesets,
    as it will compare the merge changeset against its first parent only.

    Output may be to a file, in which case the name of the file is
    given using a format string.  The formatting rules are as follows:

    %%   literal "%" character
    %H   changeset hash (40 bytes of hexadecimal)
    %N   number of patches being generated
    %R   changeset revision number
    %b   basename of the exporting repository
    %h   short-form changeset hash (12 bytes of hexadecimal)
    %n   zero-padded sequence number, starting at 1
    %r   zero-padded changeset revision number

    Without the -a option, export will avoid generating diffs of files
    it detects as binary. With -a, export will generate a diff anyway,
    probably with undesirable results.

    With the --switch-parent option, the diff will be against the second
    parent. It can be useful to review a merge.

    options:
    -o, --output     print output to file with formatted name
    -a, --text       treat all files as text
    -g, --git        use git extended diff format
    --nodates        don't include dates in diff headers
    --switch-parent  diff against the second parent

grep [OPTION]... PATTERN [FILE]...::
    Search revisions of files for a regular expression.

    This command behaves differently than Unix grep.  It only accepts
    Python/Perl regexps.  It searches repository history, not the
    working directory.  It always prints the revision number in which
    a match appears.

    By default, grep only prints output for the first revision of a
    file in which it finds a match.  To get it to print every revision
    that contains a change in match status ("-" for a match that
    becomes a non-match, or "+" for a non-match that becomes a match),
    use the --all flag.

    options:
    -0, --print0              end fields with NUL
    --all                     print all revisions that match
    -f, --follow              follow changeset history, or file
                              history across copies and renames
    -i, --ignore-case         ignore case when matching
    -l, --files-with-matches  print only filenames and revs that match
    -n, --line-number         print matching line numbers
    -r, --rev                 search in given revision range
    -u, --user                print user who committed change
    -I, --include             include names matching the given
                              patterns
    -X, --exclude             exclude names matching the given
                              patterns

heads [-r REV] [REV]...::
    With no arguments, show all repository head changesets.

    If branch or revisions names are given this will show the heads of
    the specified branches or the branches those revisions are tagged
    with.

    Repository "heads" are changesets that don't have child
    changesets. They are where development generally takes place and
    are the usual targets for update and merge operations.

    Branch heads are changesets that have a given branch tag, but have
    no child changesets with that tag.  They are usually where
    development on the given branch takes place.

    options:
    --style     display using template map file
    -r, --rev   show only heads which are descendants of rev
    --template  display with template

help [COMMAND]::
    With no arguments, print a list of commands and short help.

    Given a command name, print help for that command.

    Given an extension name, print help for that extension, and the
    commands it provides.

identify [-nibt] [-r REV] [SOURCE]::
    With no revision, print a summary of the current state of the repo.

    With a path, do a lookup in another repository.

    This summary identifies the repository state using one or two parent
    hash identifiers, followed by a "+" if there are uncommitted changes
    in the working directory, a list of tags for this revision and a branch
    name for non-default branches.

    options:
    -r, --rev     identify the specified rev
    -n, --num     show local revision number
    -i, --id      show global revision id
    -b, --branch  show branch
    -t, --tags    show tags

    aliases: id

import [-p NUM] [-m MESSAGE] [-f] PATCH...::
    Import a list of patches and commit them individually.

    If there are outstanding changes in the working directory, import
    will abort unless given the -f flag.

    You can import a patch straight from a mail message.  Even patches
    as attachments work (body part must be type text/plain or
    text/x-patch to be used).  From and Subject headers of email
    message are used as default committer and commit message.  All
    text/plain body parts before first diff are added to commit
    message.

    If the imported patch was generated by hg export, user and description
    from patch override values from message headers and body.  Values
    given on command line with -m and -u override these.

    If --exact is specified, import will set the working directory
    to the parent of each patch before applying it, and will abort
    if the resulting changeset has a different ID than the one
    recorded in the patch. This may happen due to character set
    problems or other deficiencies in the text patch format.

    To read a patch from standard input, use patch name "-".

    options:
    -p, --strip      directory strip option for patch. This has the
                     same meaning as the corresponding patch option
                     (default: 1)
    -b, --base       base path
    -f, --force      skip check for outstanding uncommitted changes
    --exact          apply patch to the nodes from which it was
                     generated
    --import-branch  Use any branch information in patch (implied by
                     --exact)
    -m, --message    use <text> as commit message
    -l, --logfile    read commit message from <file>

    aliases: patch

incoming [-p] [-n] [-M] [-f] [-r REV]... [--bundle FILENAME] [SOURCE]::
    Show new changesets found in the specified path/URL or the default
    pull location. These are the changesets that would be pulled if a pull
    was requested.

    For remote repository, using --bundle avoids downloading the changesets
    twice if the incoming is followed by a pull.

    See pull for valid source format details.

    options:
    -M, --no-merges     do not show merges
    -f, --force         run even when remote repository is unrelated
    --style             display using template map file
    -n, --newest-first  show newest record first
    --bundle            file to store the bundles into
    -p, --patch         show patch
    -r, --rev           a specific revision up to which you would like
                        to pull
    --template          display with template
    -e, --ssh           specify ssh command to use
    --remotecmd         specify hg command to run on the remote side

    aliases: in

init [-e CMD] [--remotecmd CMD] [DEST]::
    Initialize a new repository in the given directory.  If the given
    directory does not exist, it is created.

    If no directory is given, the current directory is used.

    It is possible to specify an ssh:// URL as the destination.
    Look at the help text for the pull command for important details
    about ssh:// URLs.

    options:
    -e, --ssh    specify ssh command to use
    --remotecmd  specify hg command to run on the remote side

locate [OPTION]... [PATTERN]...::
    Print all files under Mercurial control whose names match the
    given patterns.

    This command searches the entire repository by default.  To search
    just the current directory and its subdirectories, use
    "--include .".

    If no patterns are given to match, this command prints all file
    names.

    If you want to feed the output of this command into the "xargs"
    command, use the "-0" option to both this command and "xargs".
    This will avoid the problem of "xargs" treating single filenames
    that contain white space as multiple filenames.

    options:
    -r, --rev       search the repository as it stood at rev
    -0, --print0    end filenames with NUL, for use with xargs
    -f, --fullpath  print complete paths from the filesystem root
    -I, --include   include names matching the given patterns
    -X, --exclude   exclude names matching the given patterns

log [OPTION]... [FILE]::
    Print the revision history of the specified files or the entire
    project.

    File history is shown without following rename or copy history of
    files.  Use -f/--follow with a file name to follow history across
    renames and copies. --follow without a file name will only show
    ancestors or descendants of the starting revision. --follow-first
    only follows the first parent of merge revisions.

    If no revision range is specified, the default is tip:0 unless
    --follow is set, in which case the working directory parent is
    used as the starting revision.

    By default this command outputs: changeset id and hash, tags,
    non-trivial parents, user, date and time, and a summary for each
    commit. When the -v/--verbose switch is used, the list of changed
    files and full commit message is shown.

    NOTE: log -p may generate unexpected diff output for merge
    changesets, as it will compare the merge changeset against its
    first parent only. Also, the files: list will only reflect files
    that are different from BOTH parents.

    options:
    -f, --follow       follow changeset history, or file history
                       across copies and renames
    --follow-first     only follow the first parent of merge
                       changesets
    -d, --date         show revs matching date spec
    -C, --copies       show copied files
    -k, --keyword      do case-insensitive search for a keyword
    -l, --limit        limit number of changes displayed
    -r, --rev          show the specified revision or range
    --removed          include revs where files were removed
    -M, --no-merges    do not show merges
    --style            display using template map file
    -m, --only-merges  show only merges
    -p, --patch        show patch
    -P, --prune        do not display revision or any of its ancestors
    --template         display with template
    -I, --include      include names matching the given patterns
    -X, --exclude      exclude names matching the given patterns

    aliases: history

manifest [-r REV]::
    Print a list of version controlled files for the given revision.
    If no revision is given, the parent of the working directory is used,
    or tip if no revision is checked out.

    The manifest is the list of files being version controlled. If no revision
    is given then the first parent of the working directory is used.

    With -v flag, print file permissions, symlink and executable bits. With 
    --debug flag, print file revision hashes.

    options:
    -r, --rev  revision to display

merge [-f] [[-r] REV]::
    Merge the contents of the current working directory and the
    requested revision. Files that changed between either parent are
    marked as changed for the next commit and a commit must be
    performed before any further updates are allowed.

    If no revision is specified, the working directory's parent is a
    head revision, and the repository contains exactly one other head,
    the other head is merged with by default.  Otherwise, an explicit
    revision to merge with must be provided.

    options:
    -f, --force  force a merge with outstanding changes
    -r, --rev    revision to merge

outgoing [-M] [-p] [-n] [-f] [-r REV]... [DEST]::
    Show changesets not found in the specified destination repository or
    the default push location. These are the changesets that would be pushed
    if a push was requested.

    See pull for valid destination format details.

    options:
    -M, --no-merges     do not show merges
    -f, --force         run even when remote repository is unrelated
    -p, --patch         show patch
    --style             display using template map file
    -r, --rev           a specific revision you would like to push
    -n, --newest-first  show newest record first
    --template          display with template
    -e, --ssh           specify ssh command to use
    --remotecmd         specify hg command to run on the remote side

    aliases: out

parents [-r REV] [FILE]::
    Print the working directory's parent revisions. If a
    revision is given via --rev, the parent of that revision
    will be printed. If a file argument is given, revision in
    which the file was last changed (before the working directory
    revision or the argument to --rev if given) is printed.

    options:
    -r, --rev   show parents from the specified rev
    --style     display using template map file
    --template  display with template

paths [NAME]::
    Show definition of symbolic path name NAME. If no name is given, show
    definition of available names.

    Path names are defined in the [paths] section of /etc/mercurial/hgrc
    and $HOME/.hgrc.  If run inside a repository, .hg/hgrc is used, too.

pull [-u] [-f] [-r REV]... [-e CMD] [--remotecmd CMD] [SOURCE]::
    Pull changes from a remote repository to a local one.

    This finds all changes from the repository at the specified path
    or URL and adds them to the local repository. By default, this
    does not update the copy of the project in the working directory.

    Valid URLs are of the form:

      local/filesystem/path (or file://local/filesystem/path)
      http://[user@]host[:port]/[path]
      https://[user@]host[:port]/[path]
      ssh://[user@]host[:port]/[path]
      static-http://host[:port]/[path]

    Paths in the local filesystem can either point to Mercurial
    repositories or to bundle files (as created by 'hg bundle' or
    'hg incoming --bundle'). The static-http:// protocol, albeit slow,
    allows access to a Mercurial repository where you simply use a web
    server to publish the .hg directory as static content.

    An optional identifier after # indicates a particular branch, tag,
    or changeset to pull.

    Some notes about using SSH with Mercurial:
    - SSH requires an accessible shell account on the destination machine
      and a copy of hg in the remote path or specified with as remotecmd.
    - path is relative to the remote user's home directory by default.
      Use an extra slash at the start of a path to specify an absolute path:
        ssh://example.com//tmp/repository
    - Mercurial doesn't use its own compression via SSH; the right thing
      to do is to configure it in your ~/.ssh/config, e.g.:
        Host *.mylocalnetwork.example.com
          Compression no
        Host *
          Compression yes
      Alternatively specify "ssh -C" as your ssh command in your hgrc or
      with the --ssh command line option.

    options:
    -u, --update  update to new tip if changesets were pulled
    -f, --force   run even when remote repository is unrelated
    -r, --rev     a specific revision up to which you would like to
                  pull
    -e, --ssh     specify ssh command to use
    --remotecmd   specify hg command to run on the remote side

push [-f] [-r REV]... [-e CMD] [--remotecmd CMD] [DEST]::
    Push changes from the local repository to the given destination.

    This is the symmetrical operation for pull. It helps to move
    changes from the current repository to a different one. If the
    destination is local this is identical to a pull in that directory
    from the current one.

    By default, push will refuse to run if it detects the result would
    increase the number of remote heads. This generally indicates the
    the client has forgotten to sync and merge before pushing.

    Valid URLs are of the form:

      local/filesystem/path (or file://local/filesystem/path)
      ssh://[user@]host[:port]/[path]
      http://[user@]host[:port]/[path]
      https://[user@]host[:port]/[path]

    An optional identifier after # indicates a particular branch, tag,
    or changeset to push.

    Look at the help text for the pull command for important details
    about ssh:// URLs.

    Pushing to http:// and https:// URLs is only possible, if this
    feature is explicitly enabled on the remote Mercurial server.

    options:
    -f, --force  force push
    -r, --rev    a specific revision you would like to push
    -e, --ssh    specify ssh command to use
    --remotecmd  specify hg command to run on the remote side

recover::
    Recover from an interrupted commit or pull.

    This command tries to fix the repository status after an interrupted
    operation. It should only be necessary when Mercurial suggests it.

remove [OPTION]... FILE...::
    Schedule the indicated files for removal from the repository.

    This only removes files from the current branch, not from the
    entire project history.  If the files still exist in the working
    directory, they will be deleted from it.  If invoked with --after,
    files are marked as removed, but not actually unlinked unless --force
    is also given. Without exact file names, --after will only mark
    files as removed if they are no longer in the working directory.

    This command schedules the files to be removed at the next commit.
    To undo a remove before that, see hg revert.

    Modified files and added files are not removed by default.  To
    remove them, use the -f/--force option.

    options:
    -A, --after    record remove that has already occurred
    -f, --force    remove file even if modified
    -I, --include  include names matching the given patterns
    -X, --exclude  exclude names matching the given patterns

    aliases: rm

rename [OPTION]... SOURCE... DEST::
    Mark dest as copies of sources; mark sources for deletion.  If
    dest is a directory, copies are put in that directory.  If dest is
    a file, there can only be one source.

    By default, this command copies the contents of files as they
    stand in the working directory.  If invoked with --after, the
    operation is recorded, but no copying is performed.

    This command takes effect in the next commit. To undo a rename
    before that, see hg revert.

    options:
    -A, --after    record a rename that has already occurred
    -f, --force    forcibly copy over an existing managed file
    -I, --include  include names matching the given patterns
    -X, --exclude  exclude names matching the given patterns
    -n, --dry-run  do not perform actions, just print output

    aliases: mv

revert [OPTION]... [-r REV] [NAME]...::
    With no revision specified, revert the named files or directories
    to the contents they had in the parent of the working directory.
    This restores the contents of the affected files to an unmodified
    state and unschedules adds, removes, copies, and renames. If the
    working directory has two parents, you must explicitly specify the
    revision to revert to.

    Modified files are saved with a .orig suffix before reverting.
    To disable these backups, use --no-backup.

    Using the -r option, revert the given files or directories to their
    contents as of a specific revision. This can be helpful to "roll
    back" some or all of a change that should not have been committed.

    Revert modifies the working directory.  It does not commit any
    changes, or change the parent of the working directory.  If you
    revert to a revision other than the parent of the working
    directory, the reverted files will thus appear modified
    afterwards.

    If a file has been deleted, it is restored.  If the executable
    mode of a file was changed, it is reset.

    If names are given, all files matching the names are reverted.

    If no arguments are given, no files are reverted.

    options:
    -a, --all      revert all changes when no arguments given
    -d, --date     tipmost revision matching date
    -r, --rev      revision to revert to
    --no-backup    do not save backup copies of files
    -I, --include  include names matching the given patterns
    -X, --exclude  exclude names matching the given patterns
    -n, --dry-run  do not perform actions, just print output

rollback::
    Roll back the last transaction in this repository, restoring the
    project to its state prior to the transaction.

    Transactions are used to encapsulate the effects of all commands
    that create new changesets or propagate existing changesets into a
    repository. For example, the following commands are transactional,
    and their effects can be rolled back:

      commit
      import
      pull
      push (with this repository as destination)
      unbundle

    This command should be used with care. There is only one level of
    rollback, and there is no way to undo a rollback. It will also
    restore the dirstate at the time of the last transaction, which
    may lose subsequent dirstate changes.

    This command is not intended for use on public repositories. Once
    changes are visible for pull by other users, rolling a transaction
    back locally is ineffective (someone else may already have pulled
    the changes). Furthermore, a race is possible with readers of the
    repository; for example an in-progress pull from the repository
    may fail if a rollback is performed.

root::
    Print the root directory of the current repository.

serve [OPTION]...::
    Start a local HTTP repository browser and pull server.

    By default, the server logs accesses to stdout and errors to
    stderr.  Use the "-A" and "-E" options to log to files.

    options:
    -A, --accesslog   name of access log file to write to
    -d, --daemon      run server in background
    --daemon-pipefds  used internally by daemon mode
    -E, --errorlog    name of error log file to write to
    -p, --port        port to use (default: 8000)
    -a, --address     address to use
    -n, --name        name to show in web pages (default: working dir)
    --webdir-conf     name of the webdir config file (serve more than
                      one repo)
    --pid-file        name of file to write process ID to
    --stdio           for remote clients
    -t, --templates   web templates to use
    --style           template style to use
    -6, --ipv6        use IPv6 in addition to IPv4
    --certificate     SSL certificate file

showconfig [-u] [NAME]...::
    With no args, print names and values of all config items.

    With one arg of the form section.name, print just the value of
    that config item.

    With multiple args, print names and values of all config items
    with matching section names.

    options:
    -u, --untrusted  show untrusted configuration options

    aliases: debugconfig

status [OPTION]... [FILE]...::
    Show status of files in the repository.  If names are given, only
    files that match are shown.  Files that are clean or ignored, are
    not listed unless -c (clean), -i (ignored) or -A is given.

    NOTE: status may appear to disagree with diff if permissions have
    changed or a merge has occurred. The standard diff format does not
    report permission changes and diff only reports changes relative
    to one merge parent.

    If one revision is given, it is used as the base revision.
    If two revisions are given, the difference between them is shown.

    The codes used to show the status of files are:
    M = modified
    A = added
    R = removed
    C = clean
    ! = deleted, but still tracked
    ? = not tracked
    I = ignored (not shown by default)
      = the previous added file was copied from here

    options:
    -A, --all        show status of all files
    -m, --modified   show only modified files
    -a, --added      show only added files
    -r, --removed    show only removed files
    -d, --deleted    show only deleted (but tracked) files
    -c, --clean      show only files without changes
    -u, --unknown    show only unknown (not tracked) files
    -i, --ignored    show only ignored files
    -n, --no-status  hide status prefix
    -C, --copies     show source of copied files
    -0, --print0     end filenames with NUL, for use with xargs
    --rev            show difference from revision
    -I, --include    include names matching the given patterns
    -X, --exclude    exclude names matching the given patterns

    aliases: st

tag [-l] [-m TEXT] [-d DATE] [-u USER] [-r REV] NAME::
    Name a particular revision using <name>.

    Tags are used to name particular revisions of the repository and are
    very useful to compare different revision, to go back to significant
    earlier versions or to mark branch points as releases, etc.

    If no revision is given, the parent of the working directory is used,
    or tip if no revision is checked out.

    To facilitate version control, distribution, and merging of tags,
    they are stored as a file named ".hgtags" which is managed
    similarly to other project files and can be hand-edited if
    necessary.  The file '.hg/localtags' is used for local tags (not
    shared among repositories).

    options:
    -f, --force    replace existing tag
    -l, --local    make the tag local
    -r, --rev      revision to tag
    --remove       remove a tag
    -m, --message  use <text> as commit message
    -d, --date     record datecode as commit date
    -u, --user     record user as committer

tags::
    List the repository tags.

    This lists both regular and local tags.

tip [-p]::
    Show the tip revision.

    options:
    --style      display using template map file
    -p, --patch  show patch
    --template   display with template

unbundle [-u] FILE...::
    Apply one or more compressed changegroup files generated by the
    bundle command.

    options:
    -u, --update  update to new tip if changesets were unbundled

update [-C] [-d DATE] [[-r] REV]::
    Update the working directory to the specified revision, or the
    tip of the current branch if none is specified.

    If there are no outstanding changes in the working directory and
    there is a linear relationship between the current version and the
    requested version, the result is the requested version.

    To merge the working directory with another revision, use the
    merge command.

    By default, update will refuse to run if doing so would require
    discarding local changes.

    options:
    -C, --clean  overwrite locally modified files
    -d, --date   tipmost revision matching date
    -r, --rev    revision

    aliases: up checkout co

verify::
    Verify the integrity of the current repository.

    This will perform an extensive check of the repository's
    integrity, validating the hashes and checksums of each entry in
    the changelog, manifest, and tracked files, as well as the
    integrity of their crosslinks and indices.

version::
    output version and copyright information

DATE FORMATS
------------


    Some commands (backout, commit, tag) allow the user to specify a date.
    Many date formats are acceptible. Here are some examples:

    "Wed Dec 6 13:18:29 2006" (local timezone assumed)
    "Dec 6 13:18 -0600" (year assumed, time offset provided)
    "Dec 6 13:18 UTC" (UTC and GMT are aliases for +0000)
    "Dec 6" (midnight)
    "13:18" (today assumed)
    "3:39" (3:39AM assumed)
    "3:39pm" (15:39)
    "2006-12-6 13:18:29" (ISO 8601 format)
    "2006-12-6 13:18"
    "2006-12-6"
    "12-6"
    "12/6"
    "12/6/6" (Dec 6 2006)

    Lastly, there is Mercurial's internal format:

    "1165432709 0" (Wed Dec 6 13:18:29 2006 UTC)

    This is the internal representation format for dates. unixtime is
    the number of seconds since the epoch (1970-01-01 00:00 UTC). offset
    is the offset of the local timezone, in seconds west of UTC (negative
    if the timezone is east of UTC).
    
FILE NAME PATTERNS
------------------


    Mercurial accepts several notations for identifying one or more
    files at a time.

    By default, Mercurial treats filenames as shell-style extended
    glob patterns.

    Alternate pattern notations must be specified explicitly.

    To use a plain path name without any pattern matching, start a
    name with "path:".  These path names must match completely, from
    the root of the current repository.

    To use an extended glob, start a name with "glob:".  Globs are
    rooted at the current directory; a glob such as "*.c" will match
    files ending in ".c" in the current directory only.

    The supported glob syntax extensions are "**" to match any string
    across path separators, and "{a,b}" to mean "a or b".

    To use a Perl/Python regular expression, start a name with "re:".
    Regexp pattern matching is anchored at the root of the repository.

    Plain examples:

    path:foo/bar   a name bar in a directory named foo in the root of
                   the repository
    path:path:name a file or directory named "path:name"

    Glob examples:

    glob:*.c       any name ending in ".c" in the current directory
    *.c            any name ending in ".c" in the current directory
    **.c           any name ending in ".c" in the current directory, or
                   any subdirectory
    foo/*.c        any name ending in ".c" in the directory foo
    foo/**.c       any name ending in ".c" in the directory foo, or any
                   subdirectory

    Regexp examples:

    re:.*\.c$      any name ending in ".c", anywhere in the repository


ENVIRONMENT VARIABLES
---------------------


HG::
    Path to the 'hg' executable, automatically passed when running hooks,
    extensions or external tools. If unset or empty, an executable named
    'hg' (with com/exe/bat/cmd extension on Windows) is searched.

HGEDITOR::
    This is the name of the editor to use when committing. Defaults to the
    value of EDITOR.

    (deprecated, use .hgrc)

HGENCODING::
    This overrides the default locale setting detected by Mercurial.
    This setting is used to convert data including usernames,
    changeset descriptions, tag names, and branches. This setting can
    be overridden with the --encoding command-line option.

HGENCODINGMODE::
    This sets Mercurial's behavior for handling unknown characters
    while transcoding user inputs. The default is "strict", which
    causes Mercurial to abort if it can't translate a character. Other
    settings include "replace", which replaces unknown characters, and
    "ignore", which drops them. This setting can be overridden with
    the --encodingmode command-line option.

HGMERGE::
    An executable to use for resolving merge conflicts. The program
    will be executed with three arguments: local file, remote file,
    ancestor file.

    The default program is "hgmerge", which is a shell script provided
    by Mercurial with some sensible defaults.

    (deprecated, use .hgrc)

HGRCPATH::
    A list of files or directories to search for hgrc files.  Item
    separator is ":" on Unix, ";" on Windows.  If HGRCPATH is not set,
    platform default search path is used.  If empty, only .hg/hgrc of
    current repository is read.

    For each element in path, if a directory, all entries in directory
    ending with ".rc" are added to path.  Else, element itself is
    added to path.

HGUSER::
    This is the string used for the author of a commit.

    (deprecated, use .hgrc)

EMAIL::
    If HGUSER is not set, this will be used as the author for a commit.

LOGNAME::
    If neither HGUSER nor EMAIL is set, LOGNAME will be used (with
    '@hostname' appended) as the author value for a commit.

EDITOR::
    This is the name of the editor used in the hgmerge script. It will be
    used for commit messages if HGEDITOR isn't set. Defaults to 'vi'.

PYTHONPATH::
    This is used by Python to find imported modules and may need to be set
    appropriately if Mercurial is not installed system-wide.
    
